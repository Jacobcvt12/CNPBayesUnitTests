#+TITLE: Chib's estimation of the marginal density for a hierarchical finite normal mixture
#+DATE:  2015-07-17 Fri
#+email: rscharpf@jhu.edu
#+author:  Rob Scharpf

* Packages

#+begin_src R :tangle scripts/marginal_lik.R
library(RUnit)
library(CNPBayes)
library(MASS)
#+end_src 

* Galaxies data

#+begin_src R :tangle scripts/marginal_lik.R
data(galaxies)
#+end_src 

Correct the 78th observation:

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  galaxies[78] <- 26960
#+END_SRC


  
* Fit mixture model

Start by fitting the 3 component mixture model

#+begin_src R :tangle scripts/marginal_lik.R
  mp <- McmcParams(thin=100, iter=1000, burnin=1000)
  hypp <- Hyperparameters(type="marginal", k=3)
  model <- MarginalModel(data=galaxies/1000, k=3,
                         hypp=hypp,
                         mcmc.params=mp)
  fit <- posteriorSimulation(model)
#+end_src

#+BEGIN_SRC R :results value graphics
  dm <- plot(fit, ylim=c(0, 0.4), breaks=50)
#+END_SRC


The plot suggests 4 components may be a better fit.

#+BEGIN_SRC R
  hypp <- Hyperparameters(type="marginal", k=4)
  model <- MarginalModel(data=galaxies/1000, k=4,
                         hypp=hypp,
                         mcmc.params=mp)
  fit4 <- posteriorSimulation(model)
  dm4 <- plot(fit4, ylim=c(0, 0.4), breaks=50)
#+END_SRC

* Computing the marginal likelihood
** Using CNPBayes function

Compute the marginal likelihood for the K=3 model and compare to the
published marginal likellihood for the 3-cluster model with unequal
variance:

#+BEGIN_SRC R 
  published.mlik <- -228.595
  x <- computeMarginalLik2(list(fit))$marginal
  mlik <- x[[1]]["marginal"]
  print(mlik)
  tryCatch(checkEquals(as.numeric(mlik), published.mlik, tolerance=3),
           error=function(e) "CNPBayes estimate not within tolerance")
#+END_SRC

** Steps used in ~CNPBayes~ for marginal likelihood estimation 

The target posterior distribution is given by

$$ p(\psi | y ) = \frac{p(y | \psi) p(\psi)}{m(y)},$$ where the
marginal likelihood is given by $m(y)$.  We can rewrite this
expression in terms of the marginal density for $y$ as

$$ log[m(y)] = log[p(y|\psi^*)] + log[p(\psi^*)] - log[p(\psi^* |
y)]$$

for any ordinate $\psi^*$.  The first 2 terms on the RHS, the data log
liklelihood and the prior, are known and we compute these in the
following section.  In all that follows, we assume that the chain has
reached stationarity.  Convergence should be confirmed prior to
estimating the marginal likelihood.

** The data log likelihood and the log prior

The log likelihood and log prior are straightforward to compute and we
evaluate each at the modal ordinates, $\psi^*$.

*** Extracting the modal ordinates

There are several ways to do this.

#+BEGIN_SRC R
  modal.ordinates <- modes(fit)
  print(modal.ordinates)
  ## Update slots of the paramters in MarginalModel with the modal.ordinates
  fit2 <- useModes(fit)
  identical(theta(fit2), modal.ordinates[["theta"]])
  identical(sigma2(fit2), modal.ordinates[["sigma2"]])
  ## Find the modal.ordinate using argMax, which looks at log lik *
  ## prior for each MCMC iteration
  i <- argMax(fit)
  thetas <- theta(chains(fit))[i, ]
  identical(thetas, modal.ordinates[["theta"]])
#+END_SRC

*** Complete data log likelihood and log prior

The complete data log likelihood and log prior at the modal ordinates
are given by 

#+BEGIN_SRC R
  loglik <- log_lik(chains(fit))[i]
  logprior <- logPrior(chains(fit))[i]
#+END_SRC


Alternatively, the data log likelihood calculation is implemented in
  C++ and could be computed directly for the model at the modal
  ordinates:

#+BEGIN_SRC R
  (loglikC <- .Call("loglik", fit2))
#+END_SRC

We can verify the log likelihood calculation in R and there is an
existing unit test for this in CNPBayes:

#+BEGIN_SRC R
  yy <- y(fit2)
  th <- theta(fit2)
  sd <- sigma(fit2)
  p_ <- p(fit2)
  loglikR <- sum(log(p_[1]*dnorm(yy, th[1], sd[1]) + p_[2]*dnorm(yy, th[2], sd[2]) +
                         p_[3]*dnorm(yy, th[3], sd[3])))
  checkEquals(loglikR, loglikC)
#+END_SRC

The joint prior is $p(\sigma^2_0, \nu_0, \mu, \tau^2, \pi)$ and is
factored as $p(\sigma^2_0) * p(\nu_0) * p(\mu) * p(\tau^2) * p(\pi)$.

#+BEGIN_SRC R
  hypp <- hyperParams(fit2)
  eta.0 <- CNPBayes:::eta.0(hypp)
  m2.0 <- CNPBayes:::m2.0(hypp)
  lpriorR <- log(dgeom(nu.0(fit2), CNPBayes:::betas(hypp))) +
      log(dgamma(CNPBayes:::sigma2.0(fit2), CNPBayes:::a(hypp), CNPBayes:::b(hypp))) +
          log(dnorm(mu(fit2), CNPBayes:::mu.0(hypp), sqrt(CNPBayes:::tau2.0(hypp)))) +
              log(dgamma(1/tau2(fit2), 1/2*eta.0, 1/2*eta.0*m2.0)) +
                  log(gtools::ddirichlet(p(fit2), CNPBayes:::alpha(hypp)))
  lpriorC <- .Call("compute_logprior", fit2)
  checkIdentical(lpriorR, lpriorC)
#+END_SRC

The likelihood of the population-level parameters at the second stage
of the model is given by $p(\theta | \mu, \tau) p(\sigma^2 | \nu_0,
\sigma_0^2)$. We compute this in R


#+BEGIN_SRC R
  n0 <- CNPBayes:::nu.0(fit2)
  sigma2.0 <- CNPBayes:::sigma2.0(fit2)
  stage2.loglik <- sum(log(dnorm(theta(fit2), mu(fit2), tau(fit2)) *
                               dgamma(1/sigma2(fit2), 1/2*n0, 1/2*n0*sigma2.0)))
  loglikAndPrior <- loglik + stage2.loglik + logprior
#+END_SRC

Things currently missing in the CNPBayes implementation:

- The likelihood for the second-stage parameters is not currently
  provided in C.
- The likelihood of the second-stage parameters should be included
  when selecting the modal parameters.
- We should include the likelihood of the second-stage parameters when
  estimating the marginal density

** Estimation of p(\psi^* | y)

The difference in the first two terms of the expression for the
marginal density (that includes the second stage likelihood) and the
tabled value for the true log marginal density should correspond to
the true posterior probability at the modal ordinates $\psi^*$.

#+BEGIN_SRC R
  true.posterior <- loglikAndPrior - published.mlik  
#+END_SRC

Following Chib's [ref], we estimate $p(\psi|y)$ with block updates
using the following steps:

- use the existing MCMC chain to estimate $p(\theta^* | y, \sigma^*,
  \pi^*, z, \ldots)$

where $\theta^*$ is the modal ordinate estimated as argmax$_\theta$ ~
$p(y | \theta, z, \ldots) p(\theta)$.

- Run a reduced Gibb's sampler with $\theta^*$ fixed to estimate
  $p(\sigma^* | \theta^*, y, z, \ldots)$

- Run a reduced Gibb's sampler with $\theta^*$ and $\pi^*$ fixed at
  modal ordinates to estimate

  p(\pi^* | \theta^*, \sigma^{2*}, y, z, \ldots)


Note: as implemented, the parameter vector $\psi$ is restricted to the
first stage model parameters.  **We will likely need to incorporate
second-stage model parameters in p(\psi | \ldots) to accurately
estimate the posterior at the modal ordinates and the corresponding
marginal density.**

*** Block update for $\theta^*$

To begin, we compute $p(\theta^* | y, \ldots)$ which we estimate via
Rao-Blackwellization as

$$\frac1S \sum_{s=1}^S p(\theta^* | y, \psi^{(s)}, z^{(s)}),$$

where $S$ is the number of MCMC iterations in the full chain. Note
that the values of $\psi^{(s)}$ are from the existing chain at
iteration $s$.  As no additional MCMC is required, this step is
reasonably fast.  It does not matter whether we pass the object ~fit2~
or ~fit~ because the chains in these 2 objects are identical.  In the
second step, we compute the Rao-Blackwellized estimate of $p(\theta^*|
y), integrating out $z$ and parameters $\psi[-\theta]$.

#+BEGIN_SRC R
  ptheta.star <- .Call("marginal_theta", fit2)
  (p.theta.rb <- mean(ptheta.star))
#+END_SRC

*** Block update for $\sigma^{2*}$

The block update for $\sigma^{2*}$ requires running a reduced MCMC in
 which we update all model parameters except $\theta$, fixing $\theta$
 at the modal ordinate $\theta^*$ such that we have $p(\sigma^{2*} |
 y, \theta^{*}, \ldots)$.  Here, we allow the user to run fewer
 iterations by specifying an integer value for the argument $T2$ of
 the ~computeMarginalLik~ function.  The C function for the reduced
 Gibb's is called below. 

**Refactoring needed**:

- /This function is poorly named. Not sure why 'permutedz' is in the
  name/.

- Much of the code in ~.pthetastar~ is for permuting the modes.  This
  should be removed from estimation of the marginal density.  In
  particular, we should calculate the marginal density for whatever
  ordering of modes is passed in the MarginalModel object.  Permuting
  to a different set of modes would be a method defined for marginal
  model that is irrelevant for the computation of Gibb's.

- Check whether any of the methods for running the reduced Gibb's are
  outdated and can be removed

#+BEGIN_SRC R
  T <- 500
  mp.reduced <- McmcParams(iter=T, thin=2, burnin=0)
  fit.psigma2 <- fit
  mcmcParams(fit.psigma2, force=TRUE) <- mp.reduced
  ## I do not recall why z is not updated.
  ##fit.psigma2 <- .Call("permutedz_reduced1", object)
  fit.psigma2 <- .Call("reduced_thetafixed", fit.psigma2)
  checkIdentical(theta(fit.psigma2), modes(fit)[["theta"]])
  psigma.star <- .Call("p_sigma2_zpermuted", fit.psigma2)
  (p.sigma.rb <- mean(psigma.star))
#+END_SRC

*** Block update for $\pi^{*}$

The block update for the mixture probabilities, $\pi^{*}$, requires
 running a reduced MCMC in which we update all model parameters except
 $\theta$ and $\sigma^2$.  Again, we fix $\theta$ and $\sigma^2$ at
 the modal ordinate $\theta^*$ and $\sigma^{2*}$, respectively. The
 Rao-Blackwellized estimate is given by

$$p(\pi^* | y, \theta^*, \sigma^{2*}) = \frac1T \sum_{t=1}^T p(\pi^*| y, \theta^*, \sigma^{2*}, z^{(s)}, \psi^{(t)}), $$

where $psi^{t}[-\theta,-\sigma^2]$ is the vector of parameters
 (excluding \theta and \sigma^2) at iteration $t$ of the reduced
 Gibb's.  The C function for simulating $psi^{t}[-\theta,-\sigma^2]$
 from the reduced Gibb's is implemented in C+++.

** It appears that in the current implementation, a reduced Gibb's with $\theta$ and $\sigma^2$ fixed was not run.**  We run it below.  

#+BEGIN_SRC R
  fit.pi.star <- fit
  mcmcParams(fit.pi.star, force=TRUE) <- mp.reduced
  fit.pi.star <- .Call("reduced_theta_sigma_fixed", fit.pi.star)
  p.pi.star <- .Call("p_pmix_reduced", fit.pi.star)
  p.pi.rb <- mean(p.pi.star)
#+END_SRC

** Computing the marginal density

Since ~p.theta.rb~, ~p.sigma2.rb~, and ~p.pi.rb~ are already on the
log scale, the Chib's estimate of the marginal density (log-scale) is
given by

#+BEGIN_SRC R
  m.y <- loglikAndPrior - (p.theta.rb + p.sigma.rb + p.pi.rb)
#+END_SRC

Our estimate of the posterior at the modal ordinates and marginal
density differ from the corresponding true values by

#+BEGIN_SRC R
  (p.theta.rb + p.sigma.rb + p.pi.rb) - true.posterior 
#+END_SRC

Any bias of this estimator should be less than $k!$

#+BEGIN_SRC R
  bias <- m.y - published.mlik 
  bias < log(factorial(3))
#+END_SRC

** Extension of block updates to second stage model parameters $\mu, \tau^2, \nu_0,$ and $\sigma_0^2$.

#+BEGIN_SRC R 


#+END_SRC


* Speed improvement

- do not store the chains in the reduced Gibb's
- do not permute the z-labels.  If we do, do it outside the
  computation of the marginal density.  Only reasonable time to do
  this is if there is not a clear winner.











