#+TITLE: Chib's estimation of the marginal density for a hierarchical finite normal mixture
#+DATE:  2015-07-17 Fri
#+email: rscharpf@jhu.edu
#+author:  Rob Scharpf

* Packages

#+begin_src R :tangle scripts/marginal_lik.R
library(RUnit)
##library(CNPBayes)
library(MASS)
library(devtools)
load_all("~/Software/CNPBayes")
#+end_src 

* Galaxies data

#+begin_src R :tangle scripts/marginal_lik.R
data(galaxies)
#+end_src 

Correct the 78th observation:

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  galaxies[78] <- 26960
#+END_SRC


  
* Fit mixture model

Start by fitting the 3 component mixture model

#+begin_src R :tangle scripts/marginal_lik.R
  mp <- McmcParams(thin=100, iter=1000, burnin=1000, nStarts=20)
  hypp <- Hyperparameters(type="marginal", k=3)
  model <- MarginalModel(data=galaxies/1000, k=3,
                         hypp=hypp,
                         mcmc.params=mp)
  fit <- posteriorSimulation(model)
  dm <- plot(fit, ylim=c(0, 0.4), breaks=50)
#+end_src

The plot suggests 4 components may be a better fit.

#+BEGIN_SRC R 
  fit4 <- posteriorSimulation(model, k=4)
  dm4 <- plot(fit4, ylim=c(0, 0.4), breaks=50)
#+END_SRC

* Computing the marginal likelihood
** Using CNPBayes function

Compute the marginal likelihood for the K=3 model and compare to the
published marginal likellihood for the 3-cluster model with unequal
variance:

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  published.mlik <- -226.791
  x <- computeMarginalLik(list(fit))$marginal
  mlik <- x[[1]]["marginal"]
  print(mlik)
  tryCatch(checkEquals(as.numeric(mlik), published.mlik, tolerance=3),
           error=function(e) "CNPBayes estimate not within tolerance")
#+END_SRC

** Steps used in ~CNPBayes~ for marginal likelihood estimation 

The target posterior distribution is given by

$$ p(\psi | y ) = \frac{p(y | \psi) p(\psi)}{m(y)},$$ where the
marginal likelihood is given by $m(y)$.  We can rewrite this
expression in terms of the marginal density for $y$ as

$$ log[m(y)] = log[p(y|\psi^*)] + log[p(\psi^*)] - log[p(\psi^* |
y)]$$

for any ordinate $\psi^*$.  The first 2 terms on the RHS, the data log
liklelihood and the prior, are known and we compute these in the
following section.  In all that follows, we assume that the chain has
reached stationarity.  Convergence should be confirmed prior to
estimating the marginal likelihood.

** The data log likelihood and the log prior

The log likelihood and log prior are straightforward to compute and we
evaluate each at the modal ordinates, $\psi^*$.

*** Extracting the modal ordinates

There are several ways to do this.

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  modal.ordinates <- modes(fit)
  print(modal.ordinates)
  ## Update slots of the paramters in MarginalModel with the modal.ordinates
  fit2 <- useModes(fit)
  identical(theta(fit2), modal.ordinates[["theta"]])
  identical(sigma2(fit2), modal.ordinates[["sigma2"]])
  ## Find the modal.ordinate using argMax, which looks at log lik *
  ## prior for each MCMC iteration
  i <- argMax(fit)
  thetas <- theta(chains(fit))[i, ]
  identical(thetas, modal.ordinates[["theta"]])
#+END_SRC

*** Complete data log likelihood and log prior

The complete data log likelihood and log prior at the modal ordinates
are given by 

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  loglik <- modes(fit)[["loglik"]]
  logprior <- modes(fit)[["logprior"]]
#+END_SRC


Alternatively, the data log likelihood calculation is implemented in
  C++ and could be computed directly for the model at the modal
  ordinates:

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  (loglikC <- .Call("loglik", fit2))
#+END_SRC

We can verify the log likelihood calculation in R and there is an
existing unit test for this in CNPBayes:

#+BEGIN_SRC R  :tangle scripts/marginal_lik.R
  yy <- y(fit2)
  th <- theta(fit2)
  sd <- sigma(fit2)
  p_ <- p(fit2)
  loglikR <- sum(log(p_[1]*dnorm(yy, th[1], sd[1]) + p_[2]*dnorm(yy, th[2], sd[2]) +
                         p_[3]*dnorm(yy, th[3], sd[3])))
  checkEquals(loglikR, loglikC)
#+END_SRC

The joint prior is $p(\sigma^2_0, \nu_0, \mu, \tau^2, \pi)$ and is
factored as $p(\sigma^2_0)p(\nu_0)p(\mu)p(\tau^2)p(\pi)$.

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  hypp <- hyperParams(fit2)
  eta.0 <- CNPBayes:::eta.0(hypp)
  m2.0 <- CNPBayes:::m2.0(hypp)
  lpriorR <- log(dgeom(nu.0(fit2), CNPBayes:::betas(hypp))) +
      log(dgamma(CNPBayes:::sigma2.0(fit2), CNPBayes:::a(hypp), CNPBayes:::b(hypp))) +
          log(dnorm(mu(fit2), CNPBayes:::mu.0(hypp), sqrt(CNPBayes:::tau2.0(hypp)))) +
              log(dgamma(1/tau2(fit2), 1/2*eta.0, 1/2*eta.0*m2.0)) +
                  log(gtools::ddirichlet(p(fit2), CNPBayes:::alpha(hypp)))
  lpriorC <- .Call("compute_logprior", fit2)
  checkIdentical(lpriorR, lpriorC)
#+END_SRC

The likelihood of the population-level parameters at the second stage
of the model is given by $p(\theta | \mu, \tau) p(\sigma^2 | \nu_0,
\sigma_0^2)$. We compute this in R

#+name: stage2_loglik
#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  n0 <- CNPBayes:::nu.0(fit2)
  sigma2.0 <- CNPBayes:::sigma2.0(fit2)
  stage2.loglik <- sum(log(dnorm(theta(fit2), mu(fit2), tau(fit2)) *
                               dgamma(1/sigma2(fit2), 1/2*n0, 1/2*n0*sigma2.0)))
  loglikAndPrior <- loglik + stage2.loglik + logprior
#+END_SRC

Things currently missing in the CNPBayes implementation:

- The likelihood for the second-stage parameters is not currently
  provided in C.
- The likelihood of the second-stage parameters should be included
  when selecting the modal parameters.
- We should include the likelihood of the second-stage parameters when
  estimating the marginal density

** Estimation of p(\psi^* | y)


The difference in the first two terms of the expression for the
marginal density (that includes the second stage likelihood) and the
tabled value for the true log marginal density should correspond to
the true posterior probability at the modal ordinates $\psi^*$.

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  true.posterior <- loglikAndPrior - published.mlik  
#+END_SRC


*** Block updates

The objective is to estimate $p(\theta^*, \sigma^{2*}, \pi^* | y)$,
which can be expressed as

$$  p(\theta^* | y ) p(\sigma^{2*} | y, \theta^*) p(\pi^* | y, \theta^*, \sigma^{2*}).$$

The first term is

$$ p(\theta^* | y ) = \int p(\theta^* | y, \sigma^2, \pi, z) p(\sigma^2, \pi, z | y)d\sigma^2d\pi dz.$$



Note: as implemented, the estimate of the marginal posterior is
restricted to first-stage parameters.  **We will likely need to
incorporate second-stage model parameters**

**** Estimation of p(\theta^* | y)

An estimate for the first term is obtained by taking an ergodic average of

$$p(\theta^* | y, \sigma^{2(s)}, z^{(s)}),$$

using the posterior draws of (\sigma^2, \pi, z). No additional MCMC is
required for this estimate.  It does not matter whether we pass the
object ~fit2~ or ~fit~ because the chains in these 2 objects are
identical. 

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  ptheta.star <- .Call("marginal_theta", fit2)
  (p.theta.rb <- log(mean(ptheta.star)))
#+END_SRC

**** Estimation of $p(\sigma^{2*} | y, \theta^*)$

Note

$$p(\sigma^{2*} | y, \theta^*)  = \int p(\sigma^{2*} | y, \theta^*, \pi, z) p(\pi, z | y, \theta^*)d\pi dz.$$ 

To estimate $p(\sigma^{2*} | y)$, we take an ergodic average of
$p(\sigma^{2*} | y, \pi^{(s)}, z^{(s)})$ using draws of (\pi, z) from
a **reduced** Gibb's sampler. ** It is important to have draws of $z$
from [z | y, \theta*] (not [z | y]) and draws of $\pi$ from [\pi | y,
\theta*].

We allow the user to run fewer MCMC iterations in the reduced Gibbs by
 specifying an integer value for the argument $T2$ of the
 ~computeMarginalLik~ function.  The C++ function for the reduced
 Gibb's is called below.

**Refactoring needed:** 

- /This function is poorly named. Not sure why 'permutedz' is in the
  name/.

- Much of the code in ~.pthetastar~ is for permuting the modes.  This
  should be removed from estimation of the marginal density.  In
  particular, we should calculate the marginal density for whatever
  ordering of modes is passed in the MarginalModel object.  Permuting
  to a different set of modes would be a method defined for marginal
  model that is irrelevant for the computation of Gibb's.

- Check whether any of the methods for running the reduced Gibb's are
  outdated and can be removed

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  T <- 500
  mp.reduced <- McmcParams(iter=T, thin=2, burnin=0)
  fit.psigma2 <- fit
  mcmcParams(fit.psigma2, force=TRUE) <- mp.reduced
  ## I do not recall why z is not updated.
  ##fit.psigma2 <- .Call("permutedz_reduced1", object)
  fit.psigma2 <- .Call("reduced_thetafixed", fit.psigma2)
  checkIdentical(theta(fit.psigma2), modes(fit)[["theta"]])
  identical(modes(fit.psigma2), modes(fit))
  psigma.star <- .Call("p_sigma2_zpermuted", fit.psigma2)
  (p.sigma.rb <- log(mean(exp(psigma.star))))
#+END_SRC

**** Estimation of $p(\pi^* | y, \theta^*, \sigma^{2*})$  

We write the third term as

$$p(\pi^{*} | y, \theta^*, \sigma^{2*})  = \int p(\pi^* | y, \theta^*, \sigma^{2*}, z) p(z | y, \theta^*, \sigma^{2*})dz.$$ 

To estimate $p(\pi^{*} | y)$, we take an ergodic average of
$p(\pi^{*} | y, \theta^*, \sigma^{2*}, z^{(s)})$ using draws of $z
from a **reduced** Gibb's sampler. The draws of $z$ are from [z | y,
\theta^*, \sigma^{2*}]. The C function for simulating from [z|theta^*,
\sigma^{2*}] is implemented in C+++.

// It appears that in the current implementation, a reduced Gibb's
with $\theta$ and $\sigma^2$ fixed was not run./

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  fit.pi.star <- fit
  mcmcParams(fit.pi.star, force=TRUE) <- mp.reduced
  fit.pi.star <- .Call("reduced_theta_sigma_fixed", fit.pi.star)
  identical(modes(fit.pi.star), modes(fit))
  p.pi.star <- .Call("p_pmix_reduced", fit.pi.star)
  p.pi.rb <- log(mean(exp(p.pi.star)))
#+END_SRC

** Computing the marginal density

Since ~p.theta.rb~, ~p.sigma2.rb~, and ~p.pi.rb~ are already on the
log scale, the Chib's estimate of the marginal density (log-scale) is
given by

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  m.y <- loglikAndPrior - (p.theta.rb + p.sigma.rb + p.pi.rb)
#+END_SRC

Bias correction and comparison to published value:

#+BEGIN_SRC R :tangle scripts/marginal_lik.R
  m.bc <- m.y - log(factorial(3))
  m.bc - published.mlik
#+END_SRC

** Extension of block updates to second stage model parameters \mu, \tau^2, \nu_0, and \sigma_0^2.

*** Estimation of p(\mu | y, \theta^, \sigma^{2*}, \pi^*)

We have

$$p(\mu^* | y, \theta^*, \sigma^{2*}, \pi^*) = \int p(\mu^{*} | y, \theta^*, \sigma^{2*}, \pi^*, \tau^{2}, \nu_0, \sigma_0^2, z)   p(\tau^{2}, \nu_0, \sigma_0^2, z | y, \theta^*, \sigma^{2*}\pi^*)d\tau^2d \nu_0 d \sigma_0^2 dz.$$ 

To estimate $p(\mu^{*} | y, y, \theta^, \sigma^{2*}, \pi^*)$, we take
an ergodic average of $p(\pi^{*} | y, \theta^*, \sigma^{2*},
\tau^{2(s)}, \nu_0^{(s)}, \sigma_0^{2(s)}, z^{(s)})$ using draws of $z
from a **reduced** Gibb's sampler. The draws of $z$ are from [z | y,
\theta^*, \sigma^{2*}, \pi^*]. The C function for simulating from is
implemented in C+++.

#+BEGIN_SRC R 
  fit.mu.star <- fit
  mcmcParams(fit.mu.star, force=TRUE) <- mp.reduced
  fit.mu.star <- .Call("reduced_pi_fixed", fit.mu.star)
  identical(modes(fit.mu.star), modes(fit))
  p.mu.star <- dnorm(modes(fit)[["mu"]], mu.0(hypp), tau.0(hypp))
  p.mu.star <- .Call("p_pmix_reduced", fit.pi.star)
  p.pi.rb <- log(mean(exp(p.pi.star)))
#+END_SRC


* Speed improvement

- do not store the chains in the reduced Gibb's
- do not permute the z-labels.  If we do, do it outside the
  computation of the marginal density.  Only reasonable time to do
  this is if there is not a clear winner.











